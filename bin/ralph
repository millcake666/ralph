#!/usr/bin/env node
const { spawnSync } = require("child_process");
const fs = require("fs");
const os = require("os");
const path = require("path");
const readline = require("readline");

const rawArgs = process.argv.slice(2);
const args = [];
const cwd = process.cwd();
const repoRoot = path.resolve(__dirname, "..");
const globalDir = path.join(repoRoot, ".agents", "ralph");
const localDir = path.join(cwd, ".agents", "ralph");
const skillsRoot = path.join(repoRoot, "skills");
let agentOverride = null;
let installSkills = false;
let installForce = false;
let prdPath = null;
let progressPath = null;
let prdOutPath = null;

function exists(p) {
  try {
    fs.accessSync(p);
    return true;
  } catch {
    return false;
  }
}

function readPackageMeta() {
  try {
    const pkgPath = path.join(repoRoot, "package.json");
    const data = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
    return { name: data.name || "ralph", version: data.version || "0.0.0" };
  } catch {
    return { name: "ralph", version: "0.0.0" };
  }
}

function compareVersions(a, b) {
  const parse = (value) =>
    String(value || "")
      .split(".")
      .map((part) => parseInt(part, 10))
      .map((n) => (Number.isNaN(n) ? 0 : n));
  const pa = parse(a);
  const pb = parse(b);
  const len = Math.max(pa.length, pb.length);
  for (let i = 0; i < len; i += 1) {
    const da = pa[i] || 0;
    const db = pb[i] || 0;
    if (da > db) return 1;
    if (da < db) return -1;
  }
  return 0;
}

function checkForUpdate() {
  if (!process.stdout.isTTY || !process.stdin.isTTY) return null;
  if (process.env.RALPH_SKIP_UPDATE_CHECK === "1") return null;
  const { name, version } = readPackageMeta();
  const result = spawnSync("npm", ["view", name, "version"], { encoding: "utf-8" });
  if (result.status !== 0) return null;
  const latest = String(result.stdout || "").trim();
  if (!latest) return null;
  if (compareVersions(latest, version) <= 0) return null;
  return { name, current: version, latest };
}

function usage() {
  console.log(`ralph <command>

Commands:
  install [--skills] [--force]        Copy .agents/ralph into the current repo
  prd ["<request>"] [--out path]      Generate a PRD (JSON) via agent
  ping                                Minimal agent health check
  log "<message>"                     Append to .ralph/activity.log
  build [n] [--no-commit]             Run build loop (default)
  overview                            Render a human overview from PRD JSON
  help                                Show this message

Options:
  --prd <path>                        Override PRD path
  --out <path>                        Override PRD output path (prd command)
  --progress <path>                   Override progress log path
  --agent <codex|claude|droid|opencode|qwen>  Override agent runner

Notes:
- Uses local .agents/ralph if present; otherwise uses bundled defaults.
- State and logs are written to .ralph/ in the project.
`);
}

function findPrdCandidates(baseDir) {
  const tasksDir = path.join(baseDir, ".agents", "tasks");
  if (!exists(tasksDir)) {
    return [];
  }
  return fs
    .readdirSync(tasksDir)
    .filter((name) => name.toLowerCase().endsWith(".json"))
    .map((name) => path.join(tasksDir, name));
}

function defaultPrdOutputPath(baseDir, request) {
  return path.join(baseDir, ".agents", "tasks");
}

function collectJsonFiles(dirPath) {
  const files = new Map();
  if (!exists(dirPath)) {
    return files;
  }
  for (const name of fs.readdirSync(dirPath)) {
    if (!name.toLowerCase().endsWith(".json")) continue;
    const filePath = path.join(dirPath, name);
    try {
      const stat = fs.statSync(filePath);
      if (!stat.isFile()) continue;
      files.set(filePath, { mtimeMs: stat.mtimeMs, size: stat.size });
    } catch {
      // Skip files that disappear during scan.
    }
  }
  return files;
}

function snapshotPrdOutputState(baseDir, outputPath) {
  const resolved = path.resolve(baseDir, outputPath);
  if (resolved.toLowerCase().endsWith(".json")) {
    try {
      const stat = fs.statSync(resolved);
      return {
        kind: "file",
        path: resolved,
        existed: stat.isFile(),
        mtimeMs: stat.mtimeMs,
        size: stat.size,
      };
    } catch {
      return { kind: "file", path: resolved, existed: false, mtimeMs: 0, size: 0 };
    }
  }
  return { kind: "dir", path: resolved, files: collectJsonFiles(resolved) };
}

function hasPrdSaveConfirmation(snapshot) {
  if (!snapshot) return false;
  if (snapshot.kind === "file") {
    try {
      const stat = fs.statSync(snapshot.path);
      if (!stat.isFile() || stat.size <= 0) return false;
      if (!snapshot.existed) return true;
      return stat.size !== snapshot.size || stat.mtimeMs > snapshot.mtimeMs;
    } catch {
      return false;
    }
  }

  const current = collectJsonFiles(snapshot.path);
  if (current.size > snapshot.files.size) return true;
  for (const [filePath, stat] of current.entries()) {
    const previous = snapshot.files.get(filePath);
    if (!previous) return true;
    if (stat.size !== previous.size || stat.mtimeMs > previous.mtimeMs) return true;
  }
  return false;
}

function printQwenPrdTroubleshooting(outputPath) {
  console.error("Qwen PRD session ended before PRD save confirmation.");
  console.error("Troubleshooting:");
  console.error("- Stay in the same interactive terminal and answer every follow-up question.");
  console.error(`- Ensure the output path is writable: ${outputPath}`);
  console.error(
    "- Retry with explicit output: ralph prd --agent qwen --out .agents/tasks/prd-<name>.json",
  );
  console.error("- Verify your qwen CLI supports interactive interview mode.");
}

function promptForPrdRequest({ useQwenInteractive = false } = {}) {
  return new Promise((resolve) => {
    if (process.stdin.isTTY && process.stdout.isTTY) {
      const { StringDecoder } = require("string_decoder");
      const promptPrefix = "\u001B[32m>\u001B[0m ";
      const textChars = [];
      const utf8Decoder = new StringDecoder("utf8");
      const ESC = 27;
      const ENTER = 13;
      const NEWLINE = 10;
      const BACKSPACE = 8;
      const DELETE = 127;
      const ESCAPE_TIMEOUT_MS = 60;
      let cursorIndex = 0;
      let renderedLineCount = 1;
      let pendingTextBytes = [];
      let escapeBytes = null;
      let escapeTimeout = null;
      let settled = false;

      process.stdout.write("\n");
      process.stdout.write("\u001B[1;36mRalph PRD\u001B[0m\n");
      process.stdout.write("\u001B[90mDescribe the feature you want a PRD for\u001B[0m\n");
      process.stdout.write("\u001B[90mExample: A lightweight uptime monitor with email alerts\u001B[0m\n");
      process.stdout.write("\u001B[90mPress \u001B[1mOption+Enter\u001B[0m\u001B[90m for new line, \u001B[1mEnter\u001B[0m\u001B[90m to submit\u001B[0m\n");
      process.stdout.write(`\n${promptPrefix}`);

      const clearEscapeTimeout = () => {
        if (!escapeTimeout) return;
        clearTimeout(escapeTimeout);
        escapeTimeout = null;
      };

      const resetEscape = () => {
        clearEscapeTimeout();
        escapeBytes = null;
      };

      const scheduleEscapeTimeout = () => {
        clearEscapeTimeout();
        escapeTimeout = setTimeout(() => {
          escapeBytes = null;
          escapeTimeout = null;
        }, ESCAPE_TIMEOUT_MS);
      };

      const insertText = (value) => {
        if (!value) return false;
        const chars = Array.from(value);
        if (chars.length === 0) return false;
        textChars.splice(cursorIndex, 0, ...chars);
        cursorIndex += chars.length;
        return true;
      };

      const clearRenderedPrompt = () => {
        process.stdout.write("\r\u001B[K");
        for (let i = 1; i < renderedLineCount; i += 1) {
          process.stdout.write("\u001B[1A\r\u001B[K");
        }
      };

      const renderPrompt = () => {
        const fullText = textChars.join("");
        const lines = fullText.split("\n");
        clearRenderedPrompt();
        for (let i = 0; i < lines.length; i += 1) {
          if (i > 0) process.stdout.write("\n");
          process.stdout.write(promptPrefix + lines[i]);
        }
        renderedLineCount = lines.length;
        const beforeCursor = textChars.slice(0, cursorIndex).join("");
        const cursorLines = beforeCursor.split("\n");
        const cursorRow = cursorLines.length - 1;
        const cursorCol = cursorLines[cursorLines.length - 1].length;
        const lastRow = lines.length - 1;
        const upLines = lastRow - cursorRow;
        if (upLines > 0) {
          process.stdout.write(`\u001B[${upLines}A`);
        }
        process.stdout.write("\r");
        process.stdout.write(promptPrefix);
        if (cursorCol > 0) {
          process.stdout.write(`\u001B[${cursorCol}C`);
        }
      };

      const flushPendingText = () => {
        if (pendingTextBytes.length === 0) return false;
        const decoded = utf8Decoder.write(Buffer.from(pendingTextBytes));
        pendingTextBytes = [];
        return insertText(decoded);
      };

      const applyAction = (action) => {
        switch (action) {
          case "metaEnter":
            if (insertText("\n")) renderPrompt();
            return true;
          case "left":
            if (cursorIndex > 0) {
              cursorIndex -= 1;
              renderPrompt();
            }
            return true;
          case "right":
            if (cursorIndex < textChars.length) {
              cursorIndex += 1;
              renderPrompt();
            }
            return true;
          case "home":
            if (cursorIndex !== 0) {
              cursorIndex = 0;
              renderPrompt();
            }
            return true;
          case "end":
            if (cursorIndex !== textChars.length) {
              cursorIndex = textChars.length;
              renderPrompt();
            }
            return true;
          case "delete":
            if (cursorIndex < textChars.length) {
              textChars.splice(cursorIndex, 1);
              renderPrompt();
            }
            return true;
          default:
            return false;
        }
      };

      const parseEscape = (bytes) => {
        if (!bytes || bytes.length === 0 || bytes[0] !== ESC) return { done: true, action: null };
        if (bytes.length === 1) return { done: false, action: null };
        const second = bytes[1];
        if (second === ENTER || second === NEWLINE) return { done: true, action: "metaEnter" };
        if (second === 91) {
          if (bytes.length === 2) return { done: false, action: null };
          const third = bytes[2];
          if (third === 68) return { done: true, action: "left" };
          if (third === 67) return { done: true, action: "right" };
          if (third === 72) return { done: true, action: "home" };
          if (third === 70) return { done: true, action: "end" };
          if (third === 51) {
            if (bytes.length === 3) return { done: false, action: null };
            if (bytes[3] === 126) return { done: true, action: "delete" };
            return { done: true, action: null };
          }
          if (third === 49 || third === 52) {
            if (bytes.length === 3) return { done: false, action: null };
            if (bytes[3] === 126) {
              return { done: true, action: third === 49 ? "home" : "end" };
            }
            return { done: true, action: null };
          }
          return { done: true, action: null };
        }
        if (second === 79) {
          if (bytes.length === 2) return { done: false, action: null };
          const third = bytes[2];
          if (third === 68) return { done: true, action: "left" };
          if (third === 67) return { done: true, action: "right" };
          if (third === 72) return { done: true, action: "home" };
          if (third === 70) return { done: true, action: "end" };
          return { done: true, action: null };
        }
        return { done: true, action: null };
      };

      const cleanup = () => {
        process.stdin.off("data", onData);
        resetEscape();
        if (process.stdin.isTTY) {
          process.stdin.setRawMode(false);
        }
        process.stdin.pause();
      };

      const finish = (result) => {
        if (settled) return;
        settled = true;
        cleanup();
        process.stdout.write("\n");
        resolve(result);
      };

      const onData = (chunk) => {
        if (settled) return;
        let shouldRender = false;
        const bytes = chunk instanceof Buffer ? chunk : Buffer.from(chunk);
        for (const byte of bytes) {
          if (escapeBytes) {
            escapeBytes.push(byte);
            const parsed = parseEscape(escapeBytes);
            if (!parsed.done) {
              scheduleEscapeTimeout();
              continue;
            }
            applyAction(parsed.action);
            resetEscape();
            continue;
          }
          if (byte === ESC) {
            shouldRender = flushPendingText() || shouldRender;
            escapeBytes = [ESC];
            scheduleEscapeTimeout();
            continue;
          }
          if (byte === 3) {
            shouldRender = flushPendingText() || shouldRender;
            if (shouldRender) renderPrompt();
            finish({ cancelled: true, value: "" });
            return;
          }
          if (byte === ENTER || byte === NEWLINE) {
            shouldRender = flushPendingText() || shouldRender;
            if (shouldRender) renderPrompt();
            finish({ cancelled: false, value: textChars.join("") });
            return;
          }
          if (byte === BACKSPACE || byte === DELETE) {
            shouldRender = flushPendingText() || shouldRender;
            if (cursorIndex > 0) {
              textChars.splice(cursorIndex - 1, 1);
              cursorIndex -= 1;
              renderPrompt();
            }
            continue;
          }
          pendingTextBytes.push(byte);
        }
        shouldRender = flushPendingText() || shouldRender;
        if (shouldRender) renderPrompt();
      };

      process.stdin.setRawMode(true);
      process.stdin.resume();
      process.stdin.on("data", onData);
      return;
    }

    // Fallback to readline for non-interactive terminals
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });
    let settled = false;
    const finish = (result) => {
      if (settled) return;
      settled = true;
      rl.close();
      resolve(result);
    };
    rl.on("SIGINT", () => finish({ cancelled: true, value: "" }));
    process.stdout.write("Ralph PRD\n");
    process.stdout.write("Describe the feature you want a PRD for\n");
    process.stdout.write("Example: A lightweight uptime monitor with email alerts\n");
    rl.question("> ", (answer) => finish({ cancelled: false, value: answer }));
  });
}

async function resolvePrdPath({ cwd, explicitPath, label }) {
  if (explicitPath) {
    return path.resolve(cwd, explicitPath);
  }
  const candidates = findPrdCandidates(cwd);
  if (candidates.length === 0) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0];
  }
  const { intro, select, outro, isCancel } = await import("@clack/prompts");
  intro(label || "Select PRD");
  const selection = await select({
    message: "Pick a PRD JSON file",
    options: candidates.map((file) => ({
      value: file,
      label: path.relative(cwd, file),
    })),
  });
  if (isCancel(selection)) {
    outro("Cancelled.");
    process.exit(0);
  }
  outro("Selected.");
  return selection;
}

for (let i = 0; i < rawArgs.length; i += 1) {
  const arg = rawArgs[i];
  if (arg.startsWith("--agent=")) {
    agentOverride = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--agent") {
    agentOverride = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg === "--skills") {
    installSkills = true;
    continue;
  }
  if (arg === "--force") {
    installForce = true;
    continue;
  }
  if (arg.startsWith("--prd=")) {
    prdPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg.startsWith("--out=")) {
    prdOutPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--prd") {
    prdPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg === "--out") {
    prdOutPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg.startsWith("--progress=")) {
    progressPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--progress") {
    progressPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  args.push(arg);
}

const cmd = args[0];
if (cmd === "help" || cmd === "-h" || cmd === "--help") {
  usage();
  process.exit(0);
}

async function runInstallSkills() {
  const { intro, outro, select, isCancel } = await import("@clack/prompts");
  intro("Ralph skills install");

  const agent = await select({
    message: "Which agent are you using?",
    options: [
      { value: "codex", label: "codex" },
      { value: "claude", label: "claude" },
      { value: "droid", label: "droid" },
      { value: "opencode", label: "opencode" },
      { value: "qwen", label: "qwen" },
    ],
    initialValue: agentOverride || "codex",
  });
  if (isCancel(agent)) {
    outro("Cancelled.");
    process.exit(0);
  }

  const scope = await select({
    message: "Where should skills be installed?",
    options: [
      { value: "local", label: "Local (project)" },
      { value: "global", label: "Global (home directory)" },
    ],
    initialValue: "local",
  });
  if (isCancel(scope)) {
    outro("Cancelled.");
    process.exit(0);
  }

  const home = os.homedir();
  const targetRoot =
    agent === "codex"
      ? scope === "global"
        ? path.join(home, ".codex", "skills")
        : path.join(cwd, ".codex", "skills")
      : agent === "claude"
        ? scope === "global"
          ? path.join(home, ".claude", "skills")
          : path.join(cwd, ".claude", "skills")
        : agent === "droid"
          ? scope === "global"
            ? path.join(home, ".factory", "skills")
            : path.join(cwd, ".factory", "skills")
          : agent === "qwen"
            ? scope === "global"
              ? path.join(home, ".qwen", "skills")
              : path.join(cwd, ".qwen", "skills")
            : scope === "global"
              ? path.join(home, ".local", "share", "opencode", "skills")
              : path.join(cwd, ".opencode", "skills");

  const skillsToInstall = ["commit", "dev-browser", "prd"];
  fs.mkdirSync(targetRoot, { recursive: true });
  const installed = [];
  const skipped = [];

  for (const skill of skillsToInstall) {
    const source = path.join(skillsRoot, skill);
    const target = path.join(targetRoot, skill);
    if (!exists(source)) {
      skipped.push(`${skill} (missing in repo)`);
      continue;
    }
    if (exists(target) && !installForce) {
      skipped.push(`${skill} (already exists)`);
      continue;
    }
    fs.cpSync(source, target, { recursive: true, force: true });
    installed.push(skill);
  }

  if (installed.length) {
    console.log(`Installed skills to ${targetRoot}: ${installed.join(", ")}`);
  }
  if (skipped.length) {
    console.log(`Skipped: ${skipped.join(", ")}`);
  }
  outro("Done.");
}

async function main() {
  const updateInfo = checkForUpdate();
  if (updateInfo) {
    const { intro, confirm, outro, isCancel } = await import("@clack/prompts");
    intro("Ralph update available");
    const shouldUpdate = await confirm({
      message: `Update ${updateInfo.name} from ${updateInfo.current} to ${updateInfo.latest}?`,
      initialValue: true,
    });
    if (isCancel(shouldUpdate)) {
      outro("Skipped update.");
    } else if (shouldUpdate) {
      outro("Updating...");
      const result = spawnSync("npm", ["i", "-g", `${updateInfo.name}@latest`], {
        stdio: "inherit",
      });
      process.exit(result.status ?? 1);
    } else {
      outro("Skipped update.");
    }
  }

  if (cmd === "install") {
    if (exists(localDir) && !installForce) {
      console.log(`.agents/ralph already exists at ${localDir}. Skipping templates.`);
    } else {
      if (!exists(globalDir)) {
        console.error(`Bundled templates not found at ${globalDir}.`);
        process.exit(1);
      }
      fs.mkdirSync(path.dirname(localDir), { recursive: true });
      fs.cpSync(globalDir, localDir, { recursive: true, force: true });
      console.log(`Installed .agents/ralph to ${localDir}`);
    }
    const readmeSrc = path.join(repoRoot, "README.md");
    const diagramSrc = path.join(repoRoot, "diagram.svg");
    const imageSrc = path.join(repoRoot, "ralph.webp");
    if (exists(localDir)) {
      const readmeDst = path.join(localDir, "README.md");
      const diagramDst = path.join(localDir, "diagram.svg");
      const imageDst = path.join(localDir, "ralph.webp");
      if (exists(readmeSrc)) fs.copyFileSync(readmeSrc, readmeDst);
      if (exists(diagramSrc)) fs.copyFileSync(diagramSrc, diagramDst);
      if (exists(imageSrc)) fs.copyFileSync(imageSrc, imageDst);
    }
    if (installSkills) {
      await runInstallSkills();
    } else {
      const { confirm, isCancel } = await import("@clack/prompts");
      const wantsSkills = await confirm({
        message: "Install skills (commit + dev-browser + prd)?",
        initialValue: true,
      });
      if (isCancel(wantsSkills)) {
        console.log("Skipped skills install.");
      } else if (wantsSkills) {
        await runInstallSkills();
      }
    }
    process.exit(0);
  }

  const templateDir = exists(localDir) ? localDir : globalDir;
  if (!exists(templateDir)) {
    console.error("No .agents/ralph found locally and no bundled defaults available.");
    process.exit(1);
  }
  if (templateDir === localDir) {
    console.log(`Using local templates: ${localDir}`);
  } else {
    console.log(`Using bundled templates: ${globalDir}`);
  }

  const loopPath = path.join(templateDir, "loop.sh");
  if (!exists(loopPath)) {
    console.error(`loop.sh not found at ${loopPath}`);
    process.exit(1);
  }

  const loopArgs = args.length ? args : ["build"];
  const loadAgentMap = () => {
    const defaults = {
      codex: "codex exec --yolo --skip-git-repo-check -",
      claude: "claude -p --dangerously-skip-permissions \"$(cat {prompt})\"",
      droid: "droid exec --skip-permissions-unsafe -f {prompt}",
      opencode: "opencode run \"$(cat {prompt})\"",
      qwen: "qwen exec --yolo -",
    };
    const interactiveDefaults = {
      codex: "codex --yolo {prompt}",
      claude: "claude --dangerously-skip-permissions {prompt}",
      droid: "droid --skip-permissions-unsafe {prompt}",
      opencode: "opencode --prompt {prompt}",
      qwen: "qwen {prompt}",
    };
    const agentsPath = path.join(templateDir, "agents.sh");
    if (!exists(agentsPath)) {
      return {
        headless: defaults,
        interactive: interactiveDefaults,
        defaultAgent: "codex",
      };
    }
    const safePath = agentsPath.replace(/'/g, "'\\''");
    const bashCmd = [
      `source '${safePath}'`,
      'printf "DEFAULT_AGENT=%s\\n" "${DEFAULT_AGENT:-}"',
      'printf "AGENT_CODEX_CMD=%s\\n" "${AGENT_CODEX_CMD:-}"',
      'printf "AGENT_CLAUDE_CMD=%s\\n" "${AGENT_CLAUDE_CMD:-}"',
      'printf "AGENT_DROID_CMD=%s\\n" "${AGENT_DROID_CMD:-}"',
      'printf "AGENT_OPENCODE_CMD=%s\\n" "${AGENT_OPENCODE_CMD:-}"',
      'printf "AGENT_QWEN_CMD=%s\\n" "${AGENT_QWEN_CMD:-}"',
      'printf "AGENT_CODEX_INTERACTIVE_CMD=%s\\n" "${AGENT_CODEX_INTERACTIVE_CMD:-}"',
      'printf "AGENT_CLAUDE_INTERACTIVE_CMD=%s\\n" "${AGENT_CLAUDE_INTERACTIVE_CMD:-}"',
      'printf "AGENT_DROID_INTERACTIVE_CMD=%s\\n" "${AGENT_DROID_INTERACTIVE_CMD:-}"',
      'printf "AGENT_OPENCODE_INTERACTIVE_CMD=%s\\n" "${AGENT_OPENCODE_INTERACTIVE_CMD:-}"',
      'printf "AGENT_QWEN_INTERACTIVE_CMD=%s\\n" "${AGENT_QWEN_INTERACTIVE_CMD:-}"',
    ].join("; ");
    const result = spawnSync("bash", ["-lc", bashCmd], { encoding: "utf-8" });
    if (result.status !== 0) {
      return {
        headless: defaults,
        interactive: interactiveDefaults,
        defaultAgent: "codex",
      };
    }
    const parsed = new Map();
    for (const line of String(result.stdout || "").split("\n")) {
      if (!line) continue;
      const idx = line.indexOf("=");
      if (idx === -1) continue;
      parsed.set(line.slice(0, idx), line.slice(idx + 1));
    }
    const readVar = (name) => parsed.get(name) || null;
    return {
      headless: {
        codex: readVar("AGENT_CODEX_CMD") || defaults.codex,
        claude: readVar("AGENT_CLAUDE_CMD") || defaults.claude,
        droid: readVar("AGENT_DROID_CMD") || defaults.droid,
        opencode: readVar("AGENT_OPENCODE_CMD") || defaults.opencode,
        qwen: readVar("AGENT_QWEN_CMD") || defaults.qwen,
      },
      interactive: {
        codex: readVar("AGENT_CODEX_INTERACTIVE_CMD") || interactiveDefaults.codex,
        claude: readVar("AGENT_CLAUDE_INTERACTIVE_CMD") || interactiveDefaults.claude,
        droid: readVar("AGENT_DROID_INTERACTIVE_CMD") || interactiveDefaults.droid,
        opencode: readVar("AGENT_OPENCODE_INTERACTIVE_CMD") || interactiveDefaults.opencode,
        qwen: readVar("AGENT_QWEN_INTERACTIVE_CMD") || interactiveDefaults.qwen,
      },
      defaultAgent: readVar("DEFAULT_AGENT") || "codex",
    };
  };
  const agentDefs = loadAgentMap();
  const agentMap = agentDefs.headless;
  const agentInteractiveMap = agentDefs.interactive;
  const defaultAgent = agentDefs.defaultAgent || "codex";
  if (agentOverride) {
    const mapped = agentMap[agentOverride];
    if (!mapped) {
      console.error(`Unknown agent: ${agentOverride}`);
      console.error("Valid values: codex, claude, droid, opencode, qwen");
      process.exit(1);
    }
    process.env.AGENT_CMD = mapped;
  }
  const env = { ...process.env, RALPH_ROOT: cwd };
  if (!env.ACTIVITY_CMD) {
    env.ACTIVITY_CMD = "ralph log";
  }
  if (progressPath) env.PROGRESS_PATH = progressPath;
  if (templateDir === globalDir) {
    env.PROMPT_BUILD = path.join(templateDir, "PROMPT_build.md");
    env.GUARDRAILS_REF = path.join(templateDir, "references", "GUARDRAILS.md");
    env.CONTEXT_REF = path.join(templateDir, "references", "CONTEXT_ENGINEERING.md");
  }

  if (cmd === "ping") {
    const agentName = agentOverride || defaultAgent;
    const agentCmd = agentMap[agentName];
    if (!agentCmd) {
      console.error("Unknown agent for ping.");
      process.exit(1);
    }
    const agentBin = agentCmd.split(" ")[0];
    const existsResult = spawnSync(`command -v ${agentBin}`, { shell: true, stdio: "ignore" });
    if (existsResult.status !== 0) {
      console.error(`Agent command not found: ${agentBin}`);
      process.exit(1);
    }
    const promptFile = path.join(os.tmpdir(), `ralph-ping-${Date.now()}.txt`);
    fs.writeFileSync(promptFile, "Reply with <end>pong</end> only.");
    const escapePath = (value) => `'${String(value).replace(/'/g, "'\\''")}'`;
    const rendered = agentCmd.includes("{prompt}")
      ? agentCmd.replace(/\{prompt\}/g, escapePath(promptFile))
      : `cat ${escapePath(promptFile)} | ${agentCmd}`;
    const result = spawnSync(rendered, { shell: true, encoding: "utf-8" });
    const output = `${result.stdout || ""}${result.stderr || ""}`;
    if (!output.includes("<end>pong</end>")) {
      console.error("Ping failed: missing <end>pong</end>.");
      process.exit(1);
    }
    console.log("Ping OK.");
    process.exit(0);
  }

  if (cmd === "plan") {
    console.error("The plan command has been removed. Use `ralph build` with a JSON PRD.");
    process.exit(1);
  }

  if (cmd === "log") {
    const message = args.slice(1).join(" ").trim();
    if (!message) {
      console.error('Usage: ralph log "message"');
      process.exit(1);
    }
    const activityLog = path.join(cwd, ".ralph", "activity.log");
    fs.mkdirSync(path.dirname(activityLog), { recursive: true });
    const now = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    const stamp = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())} ${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
    fs.appendFileSync(activityLog, `[${stamp}] ${message}\n`);
    process.exit(0);
  }

  if (cmd === "prd") {
    let request = args.slice(1).join(" ").trim();
    const agentName = agentOverride || defaultAgent;
    const interactiveTerminal = Boolean(process.stdin.isTTY && process.stdout.isTTY);
    const isQwen = agentName === "qwen";

    if (!request) {
      // Use enhanced raw mode input for all agents
      const response = await promptForPrdRequest();
      if (response.cancelled) {
        console.log("Cancelled.");
        process.exit(0);
      }
      request = String(response.value || "");
      if (!request.trim()) {
        console.error("No description provided.");
        process.exit(1);
      }
      console.log("Generating PRD...");
    }
    const requestFile = path.join(os.tmpdir(), `ralph-prd-${Date.now()}.md`);
    fs.writeFileSync(requestFile, `${request}\n`);
    const outputPath = prdOutPath || prdPath || defaultPrdOutputPath(cwd, request);
    const resolvedOutputPath = path.resolve(cwd, outputPath);
    env.PRD_PATH = resolvedOutputPath;
    const prdAgent = interactiveTerminal
      ? agentInteractiveMap[agentName] || agentMap[agentName]
      : agentMap[agentName] || agentInteractiveMap[agentName];
    if (prdAgent) {
      env.PRD_AGENT_CMD = prdAgent;
    }
    const requireQwenSaveConfirmation = isQwen && interactiveTerminal;
    const prdOutputSnapshot = requireQwenSaveConfirmation
      ? snapshotPrdOutputState(cwd, resolvedOutputPath)
      : null;
    const prdArgs = ["prd", "--prompt", requestFile];
    const result = spawnSync(loopPath, prdArgs, {
      stdio: "inherit",
      env,
    });
    const status = result.status ?? 1;
    if (status !== 0) {
      process.exit(status);
    }
    if (requireQwenSaveConfirmation && !hasPrdSaveConfirmation(prdOutputSnapshot)) {
      printQwenPrdTroubleshooting(resolvedOutputPath);
      process.exit(1);
    }
    process.exit(0);
  }

  if (cmd === "overview") {
    const resolvedPrdPath = await resolvePrdPath({
      cwd,
      explicitPath: prdPath,
      label: "Ralph overview",
    });
    if (!resolvedPrdPath) {
      console.error("No PRD JSON files found. Run `ralph prd` first.");
      process.exit(1);
    }
    const prdText = fs.readFileSync(resolvedPrdPath, "utf-8");
    let prd;
    try {
      prd = JSON.parse(prdText);
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      console.error(`Invalid PRD JSON: ${message}`);
      process.exit(1);
    }
    const stories = Array.isArray(prd.stories) ? prd.stories : [];
    const total = stories.length;
    const done = stories.filter((s) => String(s.status || "open").toLowerCase() === "done").length;
    const inProgress = stories.filter((s) => String(s.status || "open").toLowerCase() === "in_progress").length;
    const open = total - done - inProgress;
    const gates = Array.isArray(prd.qualityGates) ? prd.qualityGates : [];
    const parsed = path.parse(resolvedPrdPath);
    const overviewPath = path.join(parsed.dir, `${parsed.name}.overview.md`);

    const lines = [];
    lines.push(`# PRD Overview${prd.project ? `: ${prd.project}` : ""}`);
    lines.push("");
    lines.push(`- File: ${path.relative(cwd, resolvedPrdPath)}`);
    lines.push(`- Stories: ${total} total (${open} open, ${inProgress} in_progress, ${done} done)`);
    lines.push("");
    lines.push("## Quality Gates");
    if (gates.length === 0) {
      lines.push("- (none)");
    } else {
      for (const gate of gates) lines.push(`- ${gate}`);
    }
    lines.push("");
    lines.push("## Stories");
    if (total === 0) {
      lines.push("- (none)");
    } else {
      for (const story of stories) {
        const status = String(story.status || "open").toLowerCase();
        const depends = Array.isArray(story.dependsOn) && story.dependsOn.length
          ? ` (depends on: ${story.dependsOn.join(", ")})`
          : "";
        lines.push(`- [${status}] ${story.id || "US-???"}: ${story.title || ""}${depends}`);
      }
    }
    fs.writeFileSync(overviewPath, `${lines.join("\n")}\n`);
    console.log(`Overview written to ${path.relative(cwd, overviewPath)}`);
    process.exit(0);
  }

  const needsPrd = cmd === "build" || !cmd;
  if (needsPrd) {
    const resolvedPrdPath = await resolvePrdPath({
      cwd,
      explicitPath: prdPath,
      label: "Ralph build",
    });
    if (!resolvedPrdPath) {
      console.error("No PRD JSON files found. Run `ralph prd` first.");
      process.exit(1);
    }
    env.PRD_PATH = resolvedPrdPath;
  }

  const result = spawnSync(loopPath, loopArgs, {
    stdio: "inherit",
    env,
  });

  process.exit(result.status ?? 1);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
